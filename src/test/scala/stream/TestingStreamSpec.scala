/*package streamimport akka.actor.ActorSystemimport akka.stream.ActorMaterializerimport akka.stream.scaladsl.{Flow, Keep, Sink, Source}import akka.stream.testkit.scaladsl.{TestSink, TestSource}import akka.testkit.{TestKit, TestProbe}import org.scalatest.BeforeAndAfterAllimport org.scalatest.wordspec.AnyWordSpecLikeimport scala.concurrent.Awaitimport scala.concurrent.duration._import scala.util.{Failure, Success}class TestingStreamSpec extends TestKit(ActorSystem("TestingakkaStream")) with AnyWordSpecLike  with BeforeAndAfterAll/* {  implicit val materilizer = ActorMaterializer  override def afterAll(): Unit = TestKit.shutdownActorSystem(system)  "A simple stream" should {    "statisfy basic assertations" in {      val simpleSource = Source(1 to 10)      val simpleSink = Sink.fold(0)((a: Int, b: Int) => a + b)      val sunFuture = simpleSource.toMat(simpleSink)(Keep.right).run()      val sum = Await.result(sunFuture, 2.second)      assert(sum == 55)    }    "integrate with test actor with materiallized value" in {      import akka.pattern.pipe      import system.dispatcher      val simpleSource = Source(1 to 10)      val simpleSink = Sink.fold(0)((a: Int, b: Int) => a + b)      val probe = TestProbe()      simpleSource.toMat(simpleSink)(Keep.right).run().pipeTo(probe.ref)      probe.expectMsg(55)    }    "integrate with a test actor based sink" in {      val simpleSource = Source(1 to 5)      val flow = Flow[Int].scan(0)(_ + _)      val probe = TestProbe()      val probeSink = Sink.actorRef(probe.ref, "completeMessage")      simpleSource.via(flow).to(probeSink).run()      probe.expectMsgAllOf(0, 1, 3, 6, 10, 15)    }    "integrate with Streams Teskit Sink" in {      val sourceUnderTest = Source(1 to 5)      val flow = Flow[Int].map(_ * 2)      val testSink = TestSink.probe[Int]      val materilizedTestvalue = sourceUnderTest.viaMat(flow)(Keep.right).toMat(testSink)(Keep.right).run()      materilizedTestvalue        .request(5)        .expectNext(2, 4, 6, 8, 10)        .expectComplete()    }    "integrate with Streams TestKit Source" in {      val sinkUnderTest = Sink.foreach[Int] {        case 13 => throw new RuntimeException("bad luck")        case _ =>      }      val testSource = TestSource.probe[Int]      val materlized = testSource.toMat(sinkUnderTest)(Keep.both).run()      val (testPublisher, resultFuture) = materlized      testPublisher.sendNext(1).sendNext(5).sendNext(13).sendComplete()      import system.dispatcher      resultFuture.onComplete {        case Success(_) => fail("the sink under test should have thrown failure")        case Failure(_) =>      }    }    "test flow with a test source and test sink" in {      val flowUnderTest = Flow[Int].map(_ * 2)      val testSource = TestSource.probe[Int]      val testSink = TestSink.probe[Int]      val materilized = testSource.via(flowUnderTest).toMat(testSink)(Keep.both).run()      val (publisher, subscriber) = materilized      publisher.sendNext(1).sendNext(5).sendNext(42).sendNext(99).sendComplete()      subscriber.request(4).expectNext(2, 10, 84, 198).expectComplete()    }  }}*/*/